#!/usr/bin/env bash
set -euo pipefail

# -------------------------------
# CONFIGURATION
# -------------------------------
PROJECT_ID="jithin-gcp-1234"
INSTANCE_NAME="vikunja-production-db"  # Added: Needed for the IAM User mapping
NAMESPACE="vikunja"
KSA_NAME="vikunja"

GSA_NAME="vikunja-cloudsql"
GSA_EMAIL="${GSA_NAME}@${PROJECT_ID}.iam.gserviceaccount.com"

# The Short Name is what Postgres actually uses (auto-generated by Google)
# We calculate it here just to display it to you at the end.
DB_USER_SHORT="${GSA_NAME}@${PROJECT_ID}.iam"

echo "----------------------------------------------------"
echo "Configuring Infrastructure for: ${PROJECT_ID}"
echo "Target DB Instance: ${INSTANCE_NAME}"
echo "----------------------------------------------------"

gcloud config set project "${PROJECT_ID}" >/dev/null

# -------------------------------
# 1. Create GCP Service Account (Idempotent)
# -------------------------------
if ! gcloud iam service-accounts describe "${GSA_EMAIL}" >/dev/null 2>&1; then
  echo "[1/5] Creating GCP Service Account: ${GSA_EMAIL}"
  gcloud iam service-accounts create "${GSA_NAME}" \
    --display-name "Vikunja Cloud SQL access"
else
  echo "[1/5] GCP Service Account already exists."
fi

# -------------------------------
# 2. Grant IAM Roles
# -------------------------------
echo "[2/5] Granting IAM Roles..."

# Role A: Connectivity (Allows the Proxy to find the instance)
gcloud projects add-iam-policy-binding "${PROJECT_ID}" \
  --member="serviceAccount:${GSA_EMAIL}" \
  --role="roles/cloudsql.client" \
  --quiet >/dev/null
echo "   - roles/cloudsql.client: GRANTED"

# Role B: Authentication (Allows the User to actually log in) -> CRITICAL FIX
gcloud projects add-iam-policy-binding "${PROJECT_ID}" \
  --member="serviceAccount:${GSA_EMAIL}" \
  --role="roles/cloudsql.instanceUser" \
  --quiet >/dev/null
echo "   - roles/cloudsql.instanceUser: GRANTED"

# -------------------------------
# 3. Create IAM User in Cloud SQL (The "IAM Trick")
# -------------------------------
# This step maps the Google Service Account to a Postgres User.
# Without this step, the database will reject the token.

echo "[3/5] Configuring Database User Mapping..."

# We check if the user exists in the instance to avoid errors
if ! gcloud sql users list --instance="${INSTANCE_NAME}" --format="value(name)" | grep -q "${DB_USER_SHORT}"; then
  echo "   - Creating IAM User in Cloud SQL instance..."
  gcloud sql users create "${DB_USER_SHORT}" \
    --instance="${INSTANCE_NAME}" \
    --type=CLOUD_IAM_SERVICE_ACCOUNT
else
  echo "   - Cloud SQL User '${DB_USER_SHORT}' already exists."
fi

# -------------------------------
# 4. Bind Workload Identity (KSA -> GSA)
# -------------------------------
echo "[4/5] Binding Workload Identity (KSA -> GSA)..."
gcloud iam service-accounts add-iam-policy-binding "${GSA_EMAIL}" \
  --role="roles/iam.workloadIdentityUser" \
  --member="serviceAccount:${PROJECT_ID}.svc.id.goog[${NAMESPACE}/${KSA_NAME}]" \
  --quiet >/dev/null

# -------------------------------
# 5. Patch Kubernetes ServiceAccount
# -------------------------------
echo "[5/5] Patching Kubernetes ServiceAccount..."
kubectl patch serviceaccount "${KSA_NAME}" \
  -n "${NAMESPACE}" \
  --type merge \
  -p "{
    \"metadata\": {
      \"annotations\": {
        \"iam.gke.io/gcp-service-account\": \"${GSA_EMAIL}\"
      }
    }
  }"

